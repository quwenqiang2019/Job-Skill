## Python-re模块
pat = re.compile(PATTERN)

- 字符串的查找替换
	- re.sub(pat,newpat,s)
- 字符串查找与匹配
	- re.match(pat, s)
	- re.search(pat, s)
	- re.findall(pat, s)
- 应用
	- 匹配网址url、邮箱
	- 使用中文正则表达式匹配指定的中文字符串
	- 使用正则表达式匹配提取字符串
- 案例
	- PATTERN=r'(?:https?:\/\/)?(?:www\.)?(?:github|gitee|gitlab)\.com\/[\w\-]+\/[\w\-]+\/(?:pulls|pull|merge_requests)\/[0-9]+'

		- `+ ：匹配前面的字符一次或多次`
		- `?：匹配前面的字符出现0次或1次`
		- `*：匹配前面的字符出现0次或多次`
		- ` \w：匹配任意一个字母或数字字符`
		- `\s : 匹配任何空白字符`
		- `\d ： 匹配任何数字字符`
		- `(..)：匹配括号中的字符串`
		- `(?:) ：是一个非捕获组，表示匹配但不捕获括号中的内容`
		- `[...]：匹配方括号中的任意一个字符`
		- `|：或操作符`

## Python-OS模块
D:\工作\gitlab项目\ospp-report\data_mgmt_ospp_report\data_analysis\__init__.py下执行：

- 1、获取当前脚本的完整绝对路径（执行脚本）
	- os.path.abspath(__file__)  
- 2、两个或更多的路径名进行拼接
	- os.path.join()
	- path = os.path.join('data', 'subdir', 'file.txt')
- 3、获取上级目录
	- os.path.dirname(os.path.abspath(__file__))= os.getcwd()=os.path.dirname(__file__)
- 4、获取上上级目录
	- print(os.path.dirname(os.getcwd()))
- 5、获取上上上级目录
	- print(os.path.join(os.getcwd(), "../.."))
	- print(os.path.dirname(os.path.dirname(os.getcwd())))
- 6、 遍历目录下的文件
	- for filename in os.listdir(filepath)

## python常见的数据类型
#### Python常用的基本数据类型有7种：数字(Number)、布尔(Booleans)、字符串(String)、列表(List)、元组(Tuple)、字典(Dictionary)、集合(Set)。
- 数字(Numbers)： 整数（int）, 浮点数（float）, 复数
- 布尔(Booleans)： True和False
- 字符串(Strings)：Uniconde字符序列, 在引号内包含
- 列表(list)： 有序的值的序列[]，有序性、可变性、可重复性
- 元组(Tuples)： 有序的值的序列且不可改变()
- 集合(Sets)： 无序的不含重复值的序列{}
- 字典(Dictionaries)： 无序的键值对的组合{k:v}

#### 引申数据类型
- 索引序列(Series):
	- 由index和value组成
	- index是索引，是一个一维列表
	- value是值，是一个一维列表
- 数据框(Dataframe)
	- 由index（索引）、colums（字段）、values（值）三部分组成
	- index和colums是一个一维列表，values是一个二维列表
- 数组(np.array)

#### python的字典和json字符串的区别
- python中，json和dict非常类似，都是key-value的形式，而且json和dict也可以非常方便的通过dumps和loads互转，但是它们之间还是有区别的：
- json：是一种数据格式，是纯字符串。可以被解析成python的dict或其他形式。
- dict：是一个完整的数据结构，是对hash table这一数据结构的实现，是一套从存储到提取都封装好的方案。它使用内置的hash函数来规划key对应的value的存储位置，从而获得O(1)的数据读取速度。


## Python 编码规范
- 每行代码不要超过79个字符，可以使用括号或反斜杠来换行。
- 在二元运算符两侧、逗号后面、冒号后面等需要的地方添加空格，但是在括号内部不需要添加空格。当'='用于指示关键字参数或默认参数值时，不要在其两侧使用空格。函数的参数列表中，逗号之后要有空格。
- 常量名：常量命名使用大写字母，下划线分隔。
- 函数名：应该小写，如果有多个单词，应该用下划线连接。私有函数在函数前加一个下划线。
- 类名：所有单词首字母大写，多个单词时，每个单词开头字母都要大写，私有类可用一个下划线开头。（例如MyClass）。
- 模块名：应该短小，并且全部小写，如果有多个单词，应该用下划线连接。
- 函数和类的定义应该用两个空行隔开，而类的方法定义应该用一个空行隔开。
- 在注释中，应该遵循一定的格式，例如在#号后面添加一个空格。
- 如果使用了import语句，应该将标准库模块放在第一组，第三方库模块放在第二组，自己编写的模块放在第三组。
- 尽量避免使用单字符变量名，除非是在循环中使用。


## 字符串格式化
- 使用%进行传递

query = '''
    SELECT salesperson, product, COUNT(*) AS num_sales
    FROM sales
    WHERE salesperson = %(salesperson)s
    GROUP BY salesperson, product
    HAVING num_sales >= %(min_sales)s
    ORDER BY num_sales DESC;
'''

formatted_query =query%{'salesperson': salesperson, 'min_sales': min_sales})

- 使用 format来指定参数名称

query = '''
    SELECT customer_id, COUNT(*) as num_orders
    FROM orders
    WHERE date >= '{start_date}' AND date <= '{end_date}'
    GROUP BY customer_id
    HAVING num_orders > {min_orders}
'''

formatted_query = query.format(start_date=start_date, end_date=end_date, min_orders=min_orders)

- 在 Python 3.6 及以上版本中，可以使用 f-string 来创建格式化字符串，即在字符串前面加上字母 "f"，然后在字符串中使用大括号 {} 来表示需要插入的值。

例如：
name = "Alice"
age = 30
print(f"My name is {name} and I am {age} years old.")
输出结果为：
My name is Alice and I am 30 years old.


## print 换行问题
- 输入单个打印值默认自动换行
- 输入多个打印值要换行设置 sep = ‘\n’ 


Print(“A”,”B”,”C”,sep=’\n’)
与
Print(‘A’)
Print(‘B’)
Print(‘C’)
等价


## Python *和**实现多参数的传入或变量的拆解
*：该位置接受任意多个非关键字（non-keyword）参数，在函数中将其转化为元组（1,2,3,4）

**：该位置接受任意多个关键字（keyword）参数，在函数**位置上转化为词典 [key:value, key:value ]，**kwargs 允许将不定长度的键值对作为参数传递给一个函数。如果想要在一个函数里处理带名字的参数，应该使用 **kwargs。

## Python使用多线程、多进程等技术来提高程序运行效率
- 多线程：使用 threading 模块可以创建多个线程，每个线程可以执行不同的任务，从而提高程序的并发能力。
- 多进程：使用 multiprocessing 模块可以创建多个进程，每个进程可以执行不同的任务，从而充分利用多核 CPU 的优势，提高程序的并发能力。例如：
- 协程：使用 asyncio 模块可以实现协程，协程是一种轻量级的线程，可以在单线程中实现并发执行。
- 多进程并发是通过创建多个进程来实现并发处理的。每个进程都有自己的地址空间和系统资源，它们之间相互独立，通过进程间通信来实现数据的共享。多进程并发的优点是稳定性高，一个进程崩溃不会影响其他进程的运行；缺点是创建进程的开销较大，进程间通信的开销也较大。
- 多线程并发是通过创建多个线程来实现并发处理的。所有线程共享同一个地址空间和系统资源，它们之间的切换开销较小。多线程并发的优点是创建线程的开销较小，线程间通信的开销也较小；缺点是稳定性较差，一个线程崩溃可能会导致整个进程崩溃。
- 在选择多进程并发和多线程并发时，需要根据实际情况进行选择。如果需要处理大量的计算密集型任务，多进程并发可能更适合，因为每个进程都有自己的 CPU 时间片；如果需要处理大量的 IO 操作，多线程并发可能更适合，因为线程切换的开销较小。



## Python 中，和；的用法
- ，主要用于给多个变量同时赋值
	- a, b, c = 1, 2, 3   # 将 1、2、3 赋值给 a、b、c
- ；主要用于一行写多个语句
	- a = 1; b = 2; c = 3


## Python异常处理
- t使用 try 和 except 语句来处理异常，并使用 else 和 finally 语句来执行其他操作。
- 装饰器封装异常处理


## Python装饰器的使用
- 作用就是在不改变已有函数代码前提下，为该函数增加新的功能。很大程度上可以减少代码的复用
- 应用场景
	- 处理异常
	- 性能测试
	- 访问控制
	- 日志记录


## Python 内置模块、第三方模块、自建模块

- 内置模块（built-in modules）：这些是**Python语言本身提供的模块，它们包含在Python的标准库中。内置模块是在Python安装时就已经包含在解释器中的模块，可以直接在代码中使用，无需额外安装**。例如，math、random和datetime等模块都是内置模块。
- 第三方模块（third-party modules）：这些模块是由Python社区中的其他开发者编写的，用于扩展Python的功能。**它们通常不包含在Python的标准库中，需要使用工具如pip来安装**。第三方模块可以提供各种功能，如数据处理、网络请求、图形界面等。例如，numpy、pandas和matplotlib等都是常用的第三方模块。
- 自建模块（user-defined modules）：这些模块是**由Python程序员自己编写的模块，用于封装可重用的代码。自建模块可以包含函数、类、变量等，并且可以在不同的Python脚本中导入和使用**。通过将相关的代码组织在自建模块中，可以提高代码的可维护性和重用性。自建模块可以是单个的Python文件，也可以是一个包含多个文件的目录结构。


## Python中模块（module）、包（package）和库（library）
- 模块（module）：模块是一个包含 Python 代码的文件。它可以包含函数、类、变量和其他可执行的代码。模块提供了一种将相关代码组织在一起并进行封装的方式，使得代码更易于理解、维护和重用。一个模块可以被其他模块导入并使用。在Python中，每个Python文件都可以被视为一个模块。
- 包（package）：包是一个包含多个模块的目录。它是一种更高级别的组织结构，用于将相关的模块组织在一起。包通常包含一个特殊的文件 __init__.py，用于标识这个目录是一个包。包的主要目的是提供一种层次化的结构，使得模块可以按照功能或主题进行组织。通过使用包，可以更好地管理和组织大型项目的代码。
- 库（library）：库是一组相关的模块或包的集合，旨在解决特定的问题或提供特定的功能。库可以由多个模块组成，这些模块通常在一个或多个包中组织。库可以被其他程序调用和使用，以提供额外的功能和工具。在Python中，有许多常用的库，如NumPy、Pandas和Matplotlib等，它们是由其他开发者编写的，用于提供各种功能，如数值计算、数据处理和可视化等。
- 总结来说，**模块是一个包含代码的文件，包是一个包含多个模块的目录，而库是一组相关的模块或包的集合。模块和包用于组织和封装代码，而库是为解决特定问题或提供特定功能而创建的模块或包的集合**。


## 常见的字符编码
- UTF-8：它是一种通用的字符编码，支持包括英文、中文和其他各种语言字符。UTF-8 是最常用的字符编码之一，也是推荐使用的默认编码。
- ASCII：它是最早的字符编码之一，只支持英文字符和一些特殊字符，不支持中文和其他非英文字符。
- GBK：它是中文字符编码的一种，支持简体中文和繁体中文字符。GBK 是 GB2312 的扩展，能够表示更多的中文字符。
- GB2312：它是中国国家标准的中文字符集编码，支持简体中文字符。
- Big5：它是繁体中文字符编码的一种，主要用于台湾地区的繁体中文。
- ISO-8859-1：也称为 Latin-1，它是西欧语言字符编码的一种，支持包括英文、法语、德语等西欧语言字符。


## python生成器的使用场景
- Python生成器是一种特殊的迭代器，可以动态地生成序列，而不是一次性生成整个序列。生成器可以通过函数或生成器表达式来创建，它们的主要优点是占用内存小、速度快、代码简洁易读。
- 以下是一些使用生成器的场景：
	- 处理大型数据集：当需要处理大型数据集时，生成器可以动态地生成数据，避免一次性将整个数据集加载到内存中。这对于处理大型文件或数据库记录非常有用，可以大大减少内存的使用。
	- 生成无限序列：生成器可以生成无限序列，这对于处理一些数学问题或模拟游戏等场景非常有用。例如，可以使用生成器生成斐波那契数列、素数序列等。
	- 惰性计算：生成器可以实现惰性计算，即只有在需要时才计算数据，而不是一次性计算所有数据。这对于处理复杂的计算或需要耗费大量时间的计算非常有用。
	- 处理流数据：当需要处理流数据时，生成器可以逐个处理数据，而不是一次性读取整个流。这对于处理网络数据、日志文件等流数据非常有用。
	- 实现协程：生成器可以用作协程，即可暂停和恢复执行的函数。这对于处理异步编程和事件驱动编程非常有用。


```python
def my_generator():
    for i in range(10):
        yield i

for num in my_generator():
    print(num)
```


## Python 中方法（m）和函数（f）之间的区别
- Python 函数是一系列以特定顺序执行的语句，让我们实现代码可重用性。Python 函数包括内置函数和用户定义的函数。
- Python 方法就像一个函数，只不过它需要附加到一个对象上。我们通过对象调用一个方法，它可能会对该对象进行更改。因此，方法属于一个类。



## Python数据类型注释
- 类型注释就像变量的名称标签，使它们能够清楚地了解它们要保存的数据类型。
- 另外，他们还与IDE 等工具配合使用，在错误发生之前捕获它们。
```Python
def add(a: int, b: int) -> int:
    return a + b
```

## 解释器（Interpreter）和编译器（Compiler）
- 解释器（Interpreter）和编译器（Compiler）是两种常见的将高级程序代码转换为可执行代码的工具。
- 解释器逐行解释源代码，并将其转换为机器代码或字节码，然后立即执行。解释器逐行读取源代码，并即时执行每一行，无需事先将整个代码转换为可执行形式。这意味着解释器在运行代码之前不会生成完整的可执行文件。
- 编译器在运行之前将整个源代码转换为机器代码或字节码，生成一个可执行文件。编译器将源代码作为输入，经过词法分析、语法分析、语义分析和优化等步骤，生成与目标平台相关的二进制代码，然后再执行可执行文件。
- 解释器语言：
	- Python：Python是一种解释型语言，通常使用Python解释器来逐行解释和执行Python代码。
	- JavaScript：JavaScript通常在Web浏览器中使用解释器来解释和执行代码。常见的JavaScript解释器包括V8（用于Chrome浏览器）和SpiderMonkey（用于Firefox浏览器）。
	- Ruby：Ruby语言也使用解释器来逐行解释和执行代码。常见的Ruby解释器包括MRI（Matz's Ruby Interpreter）和JRuby。
	- Perl：Perl是一种解释型语言，常用的解释器是Perl解释器（perl）。
- 编译器语言：
	- C：C语言通常使用编译器将源代码编译为机器码，生成可执行文件。常见的C编译器包括GCC（GNU Compiler Collection）和Clang。
	- C++：C++语言也使用编译器将源代码编译为机器码，生成可执行文件。常见的C++编译器包括GCC和Clang。
	- Java：Java语言使用Java编译器（javac）将源代码编译为字节码，然后在Java虚拟机（JVM）上执行。字节码是一种中间表示形式，可以由JVM解释执行或进行即时编译。
	- Go：Go语言使用Go编译器（go）将源代码编译为机器码，生成可执行文件。
- 同一种编程语言可以有解释器和编译器两种实现方式。例如，Python语言可以使用解释器（如CPython）来逐行解释执行代码，也可以使用编译器（如Numba、PyPy）将代码编译为机器码以提高执行速度。同样，Java语言在编译阶段将源代码编译为字节码，然后在运行时使用JVM解释执行字节码，也可以使用即时编译器（如HotSpot）将字节码编译为机器码以提高执行效率。



## python利用协程实现异步并发编程
- 协程、线程、进程（并发/并行编程模型）
	- 多线程：是在一个 cpu 上创建多个子任务，当某一个子任务休息的时候其他任务接着执行。多线程的控制是由 python 自己控制的。 子线程之间的内存是共享的，并不需要额外的数据通信机制。但是线程存在数据同步问题，所以要有锁机制。
	- **协程**：协程的实现是在一个线程内实现的，相当于流水线作业。由于线程切换的消耗比较大，所以对于并发编程，可以优先使用协程。
	- 多进程：通常利用的是多核 CPU 的优势，同时执行多个计算任务。每个进程有自己独立的内存管理，所以不同进程之间要进行数据通信比较麻烦。
- 异步与同步（针对I/O操作而言）
	- **异步**：执行 IO 操作时，不必等待执行就能得到返回结果。**用协程来实现异步**。
	- 同步：执行 IO 操作时，必须等待执行完成才得到返回结果。
- 并发与并行（针对CPU处理而言）
	- **并发**：并发指的是一个 CPU 同时处理多个程序，但是在同一时间点只会处理其中一个。并发的核心是：程序切换。因为程序切换的速度非常快，1 秒钟内可以完全很多次程序切换，肉眼无法感知。**用协程或多线程来实现并发**
	- 并行：指的是多个 CPU 同时处理多个程序，同一时间点可以处理多个。**用多进程来实现并行**


## 协程
- 协程，协程是在一个线程执行过程中可以在一个子程序的预定或者随机位置中断，然后转而执行别的子程序，在适当的时候再返回来接着执行（单一线程内部发出控制信号进行调度）。他本身是一种特殊的子程序或者称作函数。主要用于I/O密集型的场景。协程既不是进程，也不是线程，协程仅仅是一个**特殊的函数(异步函数)**，协程跟他们就不是一个level。
- 一个进程可以包含多个线程，一个线程可以包含多个协程，多个协程只能串行化运行。
	- 如何理解协程只能串行化运行：
		- 协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但是这些函数都是串行运行的。当一个协程运行时，其他协程必须挂起。如果有多核CPU的话，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内的多个协程却绝对串行的，无论有多少个CPU（核）

###协程的优点
- 由于python的GIL的存在，导致Python多线程性受到各种限制能甚至比单线程更糟。这个时候协程就发挥作用，在线程执行任务时，受制于GIL，不能并行，反而因为上下文切换更耗时，这个时候协程正可以弥补发挥作用。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。同时不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

###协程的使用场景
- 相比进程和线程，协程应该是最轻量的一种并发方案，任务切换完全由程序员自由控制，只有当上一个任务交出控制权下一个任务才能开始执行，协程和线程更适合处理 I/O 密集的场景，特别是 Python 中的多线程实际上也只是单线程中执行；而对于 CPU 密集的场景来说，多进程、多机器、多处理器才能提高程序的运行速度。

## IO密集型任务和CPU密集型任务
- IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务。
- CPU密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。


## python数据科学库
- 数据爬虫
	- Scrapy
	- BeautifulSoup
- 数据分析与科学计算
	- Pandas
	- NumPy
	- SciPy
- 数据可视化
	- Matplotlib
	- Seaborn
	- plolty
- 机器学习
	- SciKit-Learn
	- LightGBM
	- ELI5
	- PyBrain
	- Theano
	- NuPIC
	- Ramp
	- Bob
- 深度学习
	- TensorFlow
	- Keras
	- PyTorch
	- Caffe2
	- Chainer